#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
OpenAPIè®¾è®¡æ–‡æ¡£ç”Ÿæˆå™¨ - æ­£å¼ç‰ˆ v2.3
æœ€åæ›´æ–°ï¼š2025-03-17 17:45
"""

import json
import argparse
import re
import os  # æ·»åŠ osæ¨¡å—å¯¼å…¥
from jinja2 import Environment, FileSystemLoader
import pymysql

# è¦è¿‡æ»¤çš„å‚æ•°åˆ—è¡¨
FILTER_PARAMS = ['countId', 'optimizeJoinOfCountSql', 'searchCount', 'maxLimit', 'pages',"optimizeCountSql"]

# ==================== å…¨å±€é…ç½® ====================
TYPE_MAPPING = {
    "object": {
        "DateInterval": {
            "description": "æ—¶é—´åŒºé—´",
            "child_fields": ["begin", "end"]
        },
        "GeoPoint": {
            "description": "åœ°ç†åæ ‡",
            "child_fields": ["latitude", "longitude"]
        }
    }
}

DESIGN_TEMPLATE = """{# ä½¿ç”¨å‡å·æ§åˆ¶ç©ºç™½å­—ç¬¦ -#}
# {{ title }}

[TOC]

| **è½¯ä»¶** | **è½¯ä»¶ç‰ˆæœ¬** | **åŸºçº¿åç§°** |
| -------- | ------------ | ------------ |
| US       | 1.0          |              |



# **ç ”å‘ä¸­å¿ƒ**

# **{{ title }}**

| **å‚è€ƒæ–‡æ¡£** |          |      |
| ------------ | -------- | ---- |
| åºå·         | æ–‡æ¡£åç§° | é“¾æ¥ |
|              |          |      |
|              |          |      |
|              |          |      |


## **1.ä¸šåŠ¡è¯´æ˜**

### 1.1åŠŸèƒ½æ¦‚è¿°

{{ function_summary }}

### 1.2éåŠŸèƒ½æ¦‚è¿°

## 2.æ¥å£è¯´æ˜
{% for api_info in api_infos %}


### **2.{{ loop.index }}** {{ api_info.summary }}

url:{{ api_info.url }}

### è¯·æ±‚

| åºå· | å­—æ®µå | å­—æ®µæè¿° | ç±»å‹ | ç¤ºä¾‹ | å¤‡æ³¨ |
| :--- | :----- | :------- | :--- | :--- | :--- |
{% for param in api_info.request_params %}
| {{ loop.index }} | `{{ param.name }}` | {{ param.description }} | {{ param.type }} | `{{ param.example }}` |  |
{% endfor %}

### æ­£å¸¸å“åº”

| åºå· | å­—æ®µå | å­—æ®µæè¿° | ç±»å‹ | ç¤ºä¾‹ | å¤‡æ³¨ |
| :--- | :----- | :------- | :--- | :--- | :--- |
{% for param in api_info.response_params %}
| {{ loop.index }} | `{{ param.name }}` | {{ param.description }} | {{ param.type }} | `{{ param.example }}` |  |
{% endfor %}

### **å¼‚å¸¸å“åº”**

| **åºå·** | **å­—æ®µå** | **å­—æ®µæè¿°**                 | **ç±»å‹** | **ç¤ºä¾‹** | **å¤‡æ³¨** |
| -------- | ---------- | ---------------------------- | -------- | -------- | -------- |
| 1        | `code`     | ç»“æœç¼–ç                      | integer  | ``       |          |
| 2        | `msg`      | é”™è¯¯ä¿¡æ¯                     | string   | ``       |          |
| 3        | `data`    | æ•°æ®å†…å®¹  | JSON  | ``       |          |
{% endfor %}

## 3.æ•°æ®å­˜å‚¨ç»“æ„
{% for table in tables %}


### **è¡¨: {{ table.name }} - æ³¨é‡Š: {{ table.comment }}**

| åºå· | å­—æ®µå | å­—æ®µè¯´æ˜ | å­—æ®µç±»å‹ | ä¸»å¤–é”® | å…è®¸ä¸ºç©º | å¤‡æ³¨ |
| ---- | ------ | -------- | -------- | ------ | -------- | ---- |
{% for column in table.columns %}
| {{ loop.index }} | `{{ column.name }}` | {{ column.comment }} | {{ column.type }} | {{ column.key }} | {{ column.nullable }} | {{ column.remark }} |
{% endfor %}
{% endfor %}
"""

# è§£æ SQL æ–‡ä»¶ï¼Œæå–è¡¨ç»“æ„ä¿¡æ¯
def parse_sql_file(host, port, user, password, db):
    try:
        # è¿æ¥MySQLæ•°æ®åº“
        connection = pymysql.connect(
            host=host,
            port=port,
            user=user,
            password=password,
            db=db,
            charset='utf8mb4',
            cursorclass=pymysql.cursors.DictCursor
        )

        tables = []
        with connection.cursor() as cursor:
            # è·å–æ‰€æœ‰è¡¨ä¿¡æ¯
            cursor.execute("SHOW TABLES")
            # åŠ¨æ€è·å–æ•°æ®åº“åç§°
            table_key = f"Tables_in_{db}"
            table_names = [row[table_key] for row in cursor.fetchall()]
            
            for table_name in table_names:
                # è·å–è¡¨æ³¨é‡Š
                cursor.execute(f"SHOW TABLE STATUS WHERE Name = '{table_name}'")
                table_comment = cursor.fetchone()['Comment']

                # è·å–è¡¨å­—æ®µä¿¡æ¯
                cursor.execute(f"SHOW FULL COLUMNS FROM {table_name}")
                columns = []
                for column in cursor.fetchall():
                    columns.append({
                        "name": column['Field'],
                        "type": column['Type'],
                        "key": 'PRIMARY KEY' if column['Key'] == 'PRI' else '',
                        "nullable": 'æ˜¯' if column['Null'] == 'YES' else 'å¦',
                        "comment": column['Comment'],
                        "remark": ""
                    })

                tables.append({
                    "name": table_name,
                    "comment": table_comment,
                    "columns": columns
                })

        connection.close()

        # æ·»åŠ è°ƒè¯•ä¿¡æ¯
        print(f"è§£æåˆ°çš„è¡¨æ•°é‡: {len(tables)}")
        for table in tables:
            print(f"è¡¨å: {table['name']}, å­—æ®µæ•°: {len(table['columns'])}")

        return tables
    except Exception as e:
        print(f"âŒ æ•°æ®åº“è¿æ¥æˆ–æŸ¥è¯¢å¤±è´¥: {str(e)}")
        return []

# ==================== æ ¸å¿ƒæ–¹æ³• ====================
def clean_description(description):
    """æ¸…ç†æè¿°æ–‡æœ¬ï¼Œç§»é™¤æ¢è¡Œç¬¦å’Œå¤šä½™ç©ºæ ¼
    
    Args:
        description: åŸå§‹æè¿°æ–‡æœ¬
        
    Returns:
        æ¸…ç†åçš„æè¿°æ–‡æœ¬
    """
    if not description:
        return ''
    # å°†æ¢è¡Œç¬¦æ›¿æ¢ä¸ºç©ºæ ¼
    description = description.replace('\n', ' ')
    # ç§»é™¤å¤šä½™çš„ç©ºæ ¼
    description = re.sub(r'\s+', ' ', description)
    return description.strip()

def parse_schema(schema, components, prefix="", processed_refs=None):
    """ğŸ” å¢å¼ºç‰ˆschemaè§£æï¼ˆæ”¯æŒç±»å‹æ˜ å°„å’Œå¼•ç”¨å±•å¼€ï¼‰
    
    Args:
        schema: è¦è§£æçš„schemaå¯¹è±¡
        components: OpenAPIç»„ä»¶å®šä¹‰
        prefix: å½“å‰å±æ€§çš„å‰ç¼€
        processed_refs: å·²å¤„ç†çš„å¼•ç”¨é›†åˆï¼Œç”¨äºé¿å…æ— é™é€’å½’
        
    Returns:
        è§£æåçš„å‚æ•°åˆ—è¡¨
    """
    # åˆå§‹åŒ–å·²å¤„ç†å¼•ç”¨é›†åˆ
    if processed_refs is None:
        processed_refs = set()
        
    if isinstance(schema, dict):
        if '$ref' in schema:
            ref_path = schema['$ref'].split('/')
            if len(ref_path) >= 4 and ref_path[2] == 'schemas':
                schema_name = ref_path[-1]
                # æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†è¿‡è¿™ä¸ªå¼•ç”¨
                if schema_name in processed_refs:
                    return []  # å¦‚æœå·²ç»å¤„ç†è¿‡ï¼Œç›´æ¥è¿”å›ç©ºåˆ—è¡¨é¿å…æ— é™é€’å½’
                processed_refs.add(schema_name)  # æ·»åŠ åˆ°å·²å¤„ç†é›†åˆ
                ref_schema = components.get('schemas', {}).get(schema_name, {})
                return parse_schema(ref_schema, components, prefix, processed_refs)

        if 'properties' in schema:
            for type_name, config in TYPE_MAPPING['object'].items():
                if all(k in schema['properties'] for k in config['child_fields']):
                    schema['x-display-type'] = type_name
                    schema['description'] = clean_description(config['description'])
                    break

            params = []
            for prop_name, prop in schema['properties'].items():
                full_name = f"{prefix}.{prop_name}" if prefix else prop_name
                if prop_name not in FILTER_PARAMS:
                    # å¤„ç†æ•°ç»„ç±»å‹
                    if prop.get('type') == 'array' and 'items' in prop:
                        items_schema = prop['items']

                        # åˆ¤æ–­æ˜¯å¦éœ€è¦é€’å½’
                        need_recursion = False
                        item_type = 'object'  # é»˜è®¤ç±»å‹

                        # åˆ¤æ–­æ¡ä»¶ï¼šå­˜åœ¨$refå¼•ç”¨ æˆ– åŒ…å«properties æˆ– æ˜ç¡®æ˜¯objectç±»å‹
                        if '$ref' in items_schema:
                            need_recursion = True
                            item_type = 'object'
                        elif items_schema.get('type') == 'object' or 'properties' in items_schema:
                            need_recursion = True
                            item_type = 'object'
                        else:
                            item_type = items_schema.get('type', 'object')

                        # æ·»åŠ å½“å‰å±‚çº§å‚æ•°
                        params.append({
                            "name": full_name,
                            "type": f"array[{item_type}]",
                            "description": clean_description(prop.get('description', '')),
                            "example": prop.get('example', '')
                        })

                        # ä»…å½“éœ€è¦é€’å½’æ—¶å¤„ç†å­å…ƒç´ 
                        if need_recursion:
                            params.extend(parse_schema(items_schema, components, full_name, processed_refs))
                    else:
                        prop_params = parse_schema(prop, components, full_name, processed_refs)
                        if isinstance(prop_params, list):
                            params.extend(prop_params)
                        else:
                            params.append({
                                "name": full_name,
                                "type": prop.get('type', 'string'),
                                "description": clean_description(prop.get('description', '')),
                                "example": prop.get('example', '')
                            })
            return params

    return [
        {
            "name": prefix,
            "type": schema.get('type', 'string'),
            "description": clean_description(schema.get('description', '')),
            "example": schema.get('example', '')
        }
    ]

def extract_api_info(openapi_data, api_url, method):
    """ğŸ“¦ æ¥å£ä¿¡æ¯æå–ï¼ˆå®Œæ•´å®ç°ï¼‰"""
    components = openapi_data.get('components', {})
    path_config = openapi_data.get('paths', {}).get(api_url)
    if not path_config:
        return None
    config = path_config.get(method.lower())
    if not config:
        return None
    
    api_info = {
        "url": api_url,
        "method": method,
        "summary": clean_description(config.get('summary', '')),
        "request_params": [],
        "response_params": []
    }
    
    # å¤„ç†æ™®é€šå‚æ•°
    filtered_params = [
        param for param in config.get('parameters', [])
        if not (param['in'] == 'header' and param['name'] in ['Authorization', 'AuthType'])
    ]
    for param in filtered_params:
        if param['name'] not in FILTER_PARAMS:
            # å¤„ç†æè¿°ä¸­çš„ç‰¹æ®Šç¬¦å·
            description = clean_description(param.get('description', ''))
            
            # å¤„ç†æšä¸¾å€¼
            if 'enum' in param['schema']:
                enum_values = ', '.join(param['schema']['enum'])
                description = f"{description} å¯é€‰å€¼: {enum_values}"
            
            api_info['request_params'].append({
                "name": param['name'],
                "type": param['schema'].get('type', 'string'),
                "description": description,
                "example": param.get('example', '')
            })
    
    # å¤„ç†è¯·æ±‚ä½“å‚æ•°
    request_body = config.get('requestBody', {})
    for mime_type, media_type in request_body.get('content', {}).items():
        if mime_type == 'application/json':
            schema = media_type.get('schema', {})
            if schema.get('type') == 'array' and schema.get('items', {}).get('type') == 'string':
                # å¤„ç†å­—ç¬¦ä¸²æ•°ç»„ç±»å‹
                description = clean_description(schema.get('description') or 'IDé›†åˆ')
                api_info['request_params'].append({
                    "name": "[]",
                    "type": "array",
                    "description": description,
                    "example": ["11111"]
                })
            else:
                # å¤„ç†æ™®é€šå¯¹è±¡ç±»å‹
                schema = parse_schema(schema, components)
                api_info['request_params'].extend(schema)
    
    # å¤„ç†å“åº”
    for status_code, response in config.get('responses', {}).items():
        if status_code == '200':
            resp_schema = {}
            for mime_type, media_type in response.get('content', {}).items():
                if mime_type == 'application/json':
                    schema = media_type.get('schema', {})
                    if '$ref' in schema:
                        # å¤„ç†$refå¼•ç”¨
                        ref_path = schema['$ref'].split('/')
                        if len(ref_path) >= 4 and ref_path[2] == 'schemas':
                            schema_name = ref_path[-1]
                            schema = components.get('schemas', {}).get(schema_name, {})
                    resp_schema = parse_schema(schema, components)
            api_info['response_params'].extend(resp_schema)
    
    return api_info

def generate_design(openapi_file, host, port, user, password, db, api_configs, output_dir=None):
    """ğŸš€ æ–‡æ¡£ç”Ÿæˆä¸»æµç¨‹ï¼ˆå®Œæ•´å®ç°ï¼‰"""
    try:
        with open(openapi_file, 'r', encoding='utf-8') as f:
            openapi_data = json.load(f)
    except Exception as e:
        raise ValueError(f"æ–‡ä»¶åŠ è½½å¤±è´¥: {str(e)}")
    
    # ä¿®æ”¹è°ƒç”¨æ–¹å¼ï¼Œä¼ é€’æ‰€æœ‰å¿…è¦å‚æ•°
    all_tables = parse_sql_file(host, port, user, password, db)
    
    env = Environment(loader=FileSystemLoader('.'), 
                     trim_blocks=True, 
                     lstrip_blocks=True)
    template = env.from_string(DESIGN_TEMPLATE)
    
    for config in api_configs:
        title = config['title']
        function_summary = config['function_summary']
        output_file = config['output_file']
        
        # å¦‚æœæŒ‡å®šäº†è¾“å‡ºç›®å½•ï¼Œåˆ™ä¿®æ”¹è¾“å‡ºè·¯å¾„
        if output_dir:
            output_file = os.path.join(output_dir, os.path.basename(output_file))
        
        api_infos = []
        for api in config['apis']:
            api_url = api['api_url']
            method = api['method']
            api_info = extract_api_info(openapi_data, api_url, method)
            if api_info:
                api_infos.append(api_info)
            else:
                print(f"âŒ æœªæ‰¾åˆ°æ¥å£ä¿¡æ¯: {api_url} {method}")
        
        tables = []
        for table_name in config.get('tables', []):
            for table in all_tables:
                if table['name'] == table_name:
                    tables.append(table)
                    break
        
        if api_infos:
            try:
                # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
                if output_dir and not os.path.exists(output_dir):
                    os.makedirs(output_dir)
                
                with open(output_file, 'w', encoding='utf-8') as f:
                    f.write(template.render(
                        title=title,
                        function_summary=function_summary,
                        api_infos=api_infos,
                        tables=tables
                    ))
                print(f"âœ… æ–‡æ¡£ç”ŸæˆæˆåŠŸ: {output_file}")
            except IOError as e:
                print(f"âŒ æ–‡ä»¶å†™å…¥å¤±è´¥: {str(e)}")

# ==================== å…¥å£å‡½æ•° ====================
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="OpenAPIè®¾è®¡æ–‡æ¡£ç”Ÿæˆå™¨")
    parser.add_argument("--openapi", required=True, help="OpenAPIè§„èŒƒæ–‡ä»¶è·¯å¾„")
    parser.add_argument("--host", required=True, help="æ•°æ®åº“ä¸»æœºåœ°å€")
    parser.add_argument("--port", type=int, required=True, help="æ•°æ®åº“ç«¯å£")
    parser.add_argument("--user", required=True, help="æ•°æ®åº“ç”¨æˆ·å")
    parser.add_argument("--password", required=True, help="æ•°æ®åº“å¯†ç ")
    parser.add_argument("--db", required=True, help="æ•°æ®åº“åç§°")
    parser.add_argument("--config", required=True, help="é…ç½®æ–‡ä»¶è·¯å¾„ï¼ŒJSONæ ¼å¼")
    # æ–°å¢è¾“å‡ºç›®å½•å‚æ•°
    parser.add_argument("--output-dir", help="è¾“å‡ºç›®å½•è·¯å¾„")
    args = parser.parse_args()
    
    try:
        with open(args.config, 'r', encoding='utf-8') as f:
            api_configs = json.load(f)
        
        generate_design(
            openapi_file=args.openapi,
            host=args.host,
            port=args.port,
            user=args.user,
            password=args.password,
            db=args.db,
            api_configs=api_configs,
            output_dir=args.output_dir  # ä¼ é€’è¾“å‡ºç›®å½•å‚æ•°
        )
    except Exception as e:
        print(f"âŒ ç”Ÿæˆå¤±è´¥: {str(e)}")
        exit(1)


def resolve_ref(ref, components):
    """é€’å½’è§£æ$refå¼•ç”¨"""
    if not ref.startswith('#/components/'):
        return {}
    
    parts = ref.split('/')
    current = components
    for part in parts[2:]:
        current = current.get(part, {})
    return current

def process_schema(schema, components):
    memo = memo or set()
    """é€’å½’å¤„ç†schema"""
    if '$ref' in schema:
        ref = schema['$ref']
        if ref in memo:
            return {}  # é‡åˆ°å·²å¤„ç†è¿‡çš„å¼•ç”¨ç›´æ¥è¿”å›
        memo.add(ref)
        ref_schema = resolve_ref(schema['$ref'], components)
        return process_schema(ref_schema, components)
    
    result = {}
    if 'properties' in schema:
        for prop_name, prop_schema in schema['properties'].items():
            if '$ref' in prop_schema:
                ref_schema = resolve_ref(prop_schema['$ref'], components)
                result[prop_name] = process_schema(ref_schema, components)
            else:
                result[prop_name] = {
                    'type': prop_schema.get('type', ''),
                    'description': prop_schema.get('description', ''),
                    'items': process_schema(prop_schema.get('items', {}), components)
                    if prop_schema.get('type') == 'array' else None
                }
    return result

def generate_params(schema, components, prefix=''):
    """é€’å½’ç”Ÿæˆå‚æ•°è¡¨"""
    params = []
    if not schema:
        return params
    
    for name, prop in schema.items():
        full_name = f"{prefix}.{name}" if prefix else name
        if prop.get('items'):
            # å¤„ç†æ•°ç»„ç±»å‹
            params.append({
                'name': full_name,
                'description': prop['description'],
                'type': f"array[{prop['items']['type']}]",
                'example': ''
            })
            # é€’å½’å¤„ç†æ•°ç»„å…ƒç´ 
            params.extend(generate_params(prop['items'], components, full_name))
        elif isinstance(prop, dict) and 'type' in prop:
            # åŸºæœ¬ç±»å‹
            params.append({
                'name': full_name,
                'description': prop['description'],
                'type': prop['type'],
                'example': ''
            })
        else:
            # åµŒå¥—å¯¹è±¡
            params.extend(generate_params(prop, components, full_name))
    
    return params

# åœ¨ç”ŸæˆAPIæ–‡æ¡£çš„éƒ¨åˆ†ï¼Œä¿®æ”¹ä¸ºä½¿ç”¨æ–°çš„å¤„ç†é€»è¾‘
def generate_api_doc(api_info, components):
    # å¤„ç†è¯·æ±‚å‚æ•°
    request_params = []
    if 'requestBody' in api_info:
        content = api_info['requestBody']['content']
        for media_type, media_schema in content.items():
            schema = media_schema['schema']
            processed_schema = process_schema(schema, components)
            request_params = generate_params(processed_schema, components)
    
    # å¤„ç†å“åº”å‚æ•°
    response_params = []
    if 'responses' in api_info:
        for status_code, response in api_info['responses'].items():
            if 'content' in response:
                content = response['content']
                for media_type, media_schema in content.items():
                    schema = media_schema['schema']
                    processed_schema = process_schema(schema, components)
                    response_params = generate_params(processed_schema, components)